"""
Skill Scraper CLI
Generates a Bindu skill.yaml skeleton from a Python function's docstring and signature.

Usage:
    python scripts/generate_skill.py <path_to_file.py> <function_name>
"""
import argparse
import inspect
import importlib.util
import sys
import os
import subprocess
from datetime import datetime

def get_git_user_email():
    """Attempt to get the user's email from git config."""
    try:
        return subprocess.check_output(["git", "config", "user.email"]).decode().strip()
    except Exception:
        return "your.email@example.com"

def parse_docstring(doc):
    """Split docstring into description and potential args."""
    if not doc:
        return "No description provided.", {}
    lines = [l.strip() for l in doc.split('\n') if l.strip()]
    return lines[0] if lines else "No description provided.", {}

def generate_yaml(file_path, func_name):
    # 1. Load the module dynamically
    if not os.path.exists(file_path):
        print(f"Error: File {file_path} not found.")
        sys.exit(1)

    spec = importlib.util.spec_from_file_location("target_module", file_path)
    module = importlib.util.module_from_spec(spec)
    sys.modules["target_module"] = module
    try:
        spec.loader.exec_module(module)
    except Exception as e:
        print(f"Error loading module: {e}")
        sys.exit(1)

    # 2. Get the function
    if not hasattr(module, func_name):
        print(f"Error: Function '{func_name}' not found in {file_path}")
        sys.exit(1)
    
    func = getattr(module, func_name)
    
    # 3. Extract Metadata
    name = func_name.lower().replace("_", "-")
    author = get_git_user_email()
    description, _ = parse_docstring(inspect.getdoc(func))
    
    # 4. Generate Skeleton
    # We use manual string formatting to avoid adding 'PyYAML' dependency to the project 
    # just for this dev tool, ensuring it works out-of-the-box.
    yaml_content = f"""# Generated by scripts/generate_skill.py
id: {name}-v1
name: {name}
version: 0.1.0
author: {author}

description: |
  {description}

tags:
  - auto-generated
  - {name}

input_modes:
  - application/json

output_modes:
  - application/json

# Requirements extracted from environment (placeholder)
requirements:
  packages: []
  system: []
  min_memory_mb: 128

documentation:
  overview: |
    {description}
  
  use_cases:
    when_to_use:
      - "Automated tasks involving {name}"
    when_not_to_use:
      - "High latency requirements"

assessment:
  keywords:
    - {name}
  complexity_indicators:
    simple:
      - "default usage"
"""
    print(yaml_content)

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Generate skill.yaml from python function")
    parser.add_argument("file", help="Path to the python file")
    parser.add_argument("function", help="Name of the function to parse")
    
    args = parser.parse_args()
    generate_yaml(args.file, args.function)